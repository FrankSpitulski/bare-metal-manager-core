/*
 * SPDX-FileCopyrightText: Copyright (c) 2021-2026 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * SPDX-License-Identifier: LicenseRef-NvidiaProprietary
 *
 * NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
 * property and proprietary rights in and to this material, related
 * documentation and any modifications thereto. Any use, reproduction,
 * disclosure or distribution of this material and related documentation
 * without an express license agreement from NVIDIA CORPORATION or
 * its affiliates is strictly prohibited.
 */

//! Tests that DPF state handling is safe under duplicate events.
//!
//! The DPF watcher fires callbacks on every DPU resource update, not
//! only on phase transitions. Each callback enqueues the host for state
//! handling, so duplicate events cause the state controller to process
//! the same host multiple times in the same state. These tests verify
//! that repeated processing produces the same correct outcome.

use std::collections::HashMap;
use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::Duration;

use carbide_dpf::DpuPhase;
use carbide_uuid::machine::MachineId;
use libredfish::SystemPowerControl;
use model::machine::{DpfState, DpuInitState, ManagedHostState};
use tokio::time::timeout;

use crate::dpf::MockDpfOperations;
use crate::redfish::test_support::RedfishSimAction;
use crate::tests::common::api_fixtures::{
    TestEnvOverrides, TestManagedHost, create_managed_host_with_dpf,
    create_test_env_with_overrides, get_config, reboot_completed,
};

const TEST_TIMEOUT: Duration = Duration::from_secs(30);
const DUPLICATE_ITERATIONS: usize = 10;

fn dpf_config() -> crate::cfg::file::DpfConfig {
    crate::cfg::file::DpfConfig {
        enabled: true,
        bfb_url: "http://example.com/test.bfb".to_string(),
        deployment_name: None,
        services: None,
    }
}

fn expect_provisioning(mock: &mut MockDpfOperations) {
    mock.expect_create_initialization_objects()
        .returning(|_| Ok(()));
    mock.expect_register_dpu_device().returning(|_| Ok(()));
    mock.expect_register_dpu_node().returning(|_| Ok(()));
    mock.expect_get_dpu_phase()
        .returning(|_, _| Ok(DpuPhase::Ready));
}

async fn reset_host_to_waiting_for_ready(
    pool: &sqlx::PgPool,
    host_id: &MachineId,
    dpu_id: &MachineId,
) {
    let state = ManagedHostState::DPUInit {
        dpu_states: model::machine::DpuInitStates {
            states: HashMap::from([(
                *dpu_id,
                DpuInitState::DpfStates {
                    state: DpfState::WaitingForReady { phase: None },
                },
            )]),
        },
    };
    let state_json = serde_json::to_value(&state).unwrap();
    let version = format!("V999-T{}", chrono::Utc::now().timestamp_micros());

    sqlx::query(
        "UPDATE machines SET \
            controller_state = $1, \
            controller_state_version = $2, \
            controller_state_outcome = NULL, \
            health_report_overrides = '{\"merges\": {}, \"replace\": null}'::jsonb, \
            last_reboot_requested = NULL, \
            last_reboot_time = NULL \
         WHERE id = $3",
    )
    .bind(sqlx::types::Json(&state_json))
    .bind(&version)
    .bind(host_id)
    .execute(pool)
    .await
    .unwrap();
}

async fn get_host_state(
    env: &crate::tests::common::api_fixtures::TestEnv,
    mh: &TestManagedHost,
) -> ManagedHostState {
    let mut txn = env.db_txn().await;
    let machine = mh.host().db_machine(&mut txn).await;
    machine.state.value
}

/// Many iterations while the device is ready and no reboot is required.
/// The host must reach Ready and stay there despite repeated processing.
#[crate::sqlx_test]
async fn test_duplicate_ready_events_reach_ready(pool: sqlx::PgPool) {
    let mut mock = MockDpfOperations::new();
    expect_provisioning(&mut mock);
    mock.expect_is_dpu_device_ready().returning(|_| Ok(true));
    mock.expect_release_maintenance_hold().returning(|_| Ok(()));
    mock.expect_is_reboot_required().returning(|_| Ok(false));

    let dpf_sdk: Arc<dyn crate::dpf::DpfOperations> = Arc::new(mock);
    let mut config = get_config();
    config.dpf = dpf_config();

    let env = create_test_env_with_overrides(
        pool.clone(),
        TestEnvOverrides::with_config(config).with_dpf_sdk(dpf_sdk),
    )
    .await;

    let mh = timeout(TEST_TIMEOUT, create_managed_host_with_dpf(&env))
        .await
        .expect("timed out during initial provisioning");

    reset_host_to_waiting_for_ready(&pool, &mh.id, &mh.dpu_ids[0]).await;

    // Simulate duplicate events: run many iterations for the same state.
    timeout(TEST_TIMEOUT, async {
        for _ in 0..DUPLICATE_ITERATIONS {
            env.run_machine_state_controller_iteration().await;
        }
    })
    .await
    .expect("timed out during duplicate iterations");

    let host = get_host_state(&env, &mh).await;
    assert!(
        !matches!(host, ManagedHostState::DPUInit { .. }),
        "Host should have transitioned out of DPUInit after {} iterations, got: {:?}",
        DUPLICATE_ITERATIONS,
        host
    );
}

/// Many iterations while reboot is required. ForceRestart must be issued
/// exactly once regardless of how many times the state is processed.
#[crate::sqlx_test]
async fn test_duplicate_reboot_events_send_single_reboot(pool: sqlx::PgPool) {
    let mut mock = MockDpfOperations::new();
    expect_provisioning(&mut mock);

    let device_ready = Arc::new(AtomicBool::new(true));
    let dr = device_ready.clone();
    mock.expect_is_dpu_device_ready()
        .returning(move |_| Ok(dr.load(Ordering::SeqCst)));
    mock.expect_release_maintenance_hold().returning(|_| Ok(()));

    let reboot_required = Arc::new(AtomicBool::new(false));
    let rr = reboot_required.clone();
    mock.expect_is_reboot_required()
        .returning(move |_| Ok(rr.load(Ordering::SeqCst)));

    let dpf_sdk: Arc<dyn crate::dpf::DpfOperations> = Arc::new(mock);
    let mut config = get_config();
    config.dpf = dpf_config();

    let env = create_test_env_with_overrides(
        pool.clone(),
        TestEnvOverrides::with_config(config).with_dpf_sdk(dpf_sdk),
    )
    .await;

    let mh = timeout(TEST_TIMEOUT, create_managed_host_with_dpf(&env))
        .await
        .expect("timed out during initial provisioning");

    reboot_required.store(true, Ordering::SeqCst);
    device_ready.store(false, Ordering::SeqCst);

    reset_host_to_waiting_for_ready(&pool, &mh.id, &mh.dpu_ids[0]).await;

    let redfish_timepoint = env.redfish_sim.timepoint();

    // Simulate duplicate reboot events: many iterations in the same state.
    timeout(TEST_TIMEOUT, async {
        for _ in 0..DUPLICATE_ITERATIONS {
            env.run_machine_state_controller_iteration().await;
        }
    })
    .await
    .expect("timed out during duplicate iterations");

    let actions = env
        .redfish_sim
        .actions_since(&redfish_timepoint)
        .all_hosts();
    let reboot_count = actions
        .iter()
        .filter(|x| matches!(x, RedfishSimAction::Power(SystemPowerControl::ForceRestart)))
        .count();

    assert_eq!(
        reboot_count, 1,
        "ForceRestart must be sent exactly once despite {} duplicate iterations, got {}",
        DUPLICATE_ITERATIONS, reboot_count
    );
}

/// Many iterations after reboot completes. The host must advance
/// past DPUInit and not regress or panic.
#[crate::sqlx_test]
async fn test_duplicate_events_after_reboot_complete(pool: sqlx::PgPool) {
    let mut mock = MockDpfOperations::new();
    expect_provisioning(&mut mock);

    mock.expect_is_dpu_device_ready().returning(|_| Ok(true));
    mock.expect_release_maintenance_hold().returning(|_| Ok(()));

    let reboot_required = Arc::new(AtomicBool::new(false));
    let rr = reboot_required.clone();
    mock.expect_is_reboot_required()
        .returning(move |_| Ok(rr.load(Ordering::SeqCst)));
    let rr2 = reboot_required.clone();
    mock.expect_reboot_complete().returning(move |_| {
        rr2.store(false, Ordering::SeqCst);
        Ok(())
    });

    let dpf_sdk: Arc<dyn crate::dpf::DpfOperations> = Arc::new(mock);
    let mut config = get_config();
    config.dpf = dpf_config();

    let env = create_test_env_with_overrides(
        pool.clone(),
        TestEnvOverrides::with_config(config).with_dpf_sdk(dpf_sdk),
    )
    .await;

    let mh = timeout(TEST_TIMEOUT, create_managed_host_with_dpf(&env))
        .await
        .expect("timed out during initial provisioning");

    reboot_required.store(true, Ordering::SeqCst);

    reset_host_to_waiting_for_ready(&pool, &mh.id, &mh.dpu_ids[0]).await;

    // Process through reboot.
    timeout(TEST_TIMEOUT, async {
        for _ in 0..3 {
            env.run_machine_state_controller_iteration().await;
        }
    })
    .await
    .expect("timed out during reboot iterations");

    reboot_completed(&env, mh.id).await;

    // Simulate duplicate events after reboot: many iterations.
    timeout(TEST_TIMEOUT, async {
        for _ in 0..DUPLICATE_ITERATIONS {
            env.run_machine_state_controller_iteration().await;
        }
    })
    .await
    .expect("timed out during post-reboot duplicate iterations");

    let host = get_host_state(&env, &mh).await;
    assert!(
        !matches!(host, ManagedHostState::DPUInit { .. }),
        "Host should have transitioned out of DPUInit after reboot + {} duplicate iterations, got: {:?}",
        DUPLICATE_ITERATIONS,
        host
    );
}

/// Duplicate events while the device is NOT ready. The host must stay
/// in DPUInit/WaitingForReady without panicking or regressing.
#[crate::sqlx_test]
async fn test_duplicate_events_while_not_ready(pool: sqlx::PgPool) {
    let mut mock = MockDpfOperations::new();
    expect_provisioning(&mut mock);

    let device_ready = Arc::new(AtomicBool::new(true));
    let dr = device_ready.clone();
    mock.expect_is_dpu_device_ready()
        .returning(move |_| Ok(dr.load(Ordering::SeqCst)));
    mock.expect_release_maintenance_hold().returning(|_| Ok(()));
    mock.expect_is_reboot_required().returning(|_| Ok(false));

    let dpf_sdk: Arc<dyn crate::dpf::DpfOperations> = Arc::new(mock);
    let mut config = get_config();
    config.dpf = dpf_config();

    let env = create_test_env_with_overrides(
        pool.clone(),
        TestEnvOverrides::with_config(config).with_dpf_sdk(dpf_sdk),
    )
    .await;

    let mh = timeout(TEST_TIMEOUT, create_managed_host_with_dpf(&env))
        .await
        .expect("timed out during initial provisioning");

    device_ready.store(false, Ordering::SeqCst);

    reset_host_to_waiting_for_ready(&pool, &mh.id, &mh.dpu_ids[0]).await;

    // Simulate many duplicate events while device is not ready.
    timeout(TEST_TIMEOUT, async {
        for _ in 0..DUPLICATE_ITERATIONS {
            env.run_machine_state_controller_iteration().await;
        }
    })
    .await
    .expect("timed out during duplicate iterations");

    let host = get_host_state(&env, &mh).await;
    assert!(
        matches!(host, ManagedHostState::DPUInit { .. }),
        "Host should remain in DPUInit while device is not ready, got: {:?}",
        host
    );

    // Now make device ready and run more duplicate iterations.
    device_ready.store(true, Ordering::SeqCst);

    timeout(TEST_TIMEOUT, async {
        for _ in 0..DUPLICATE_ITERATIONS {
            env.run_machine_state_controller_iteration().await;
        }
    })
    .await
    .expect("timed out during post-ready duplicate iterations");

    let host = get_host_state(&env, &mh).await;
    assert!(
        !matches!(host, ManagedHostState::DPUInit { .. }),
        "Host should have transitioned out of DPUInit after device became ready, got: {:?}",
        host
    );
}
